-- Test cases for warning generation.

-- Redundant casts
-- ---------------

[case testRedundantCast]
# flags: warn-redundant-casts
from typing import cast
a = 1
b = cast(str, a)
c = cast(int, a)
[out]
main:5: note: Redundant cast to "int"

[case testRedundantCastWithIsinstance]
# flags: warn-redundant-casts
from typing import cast, Union
x = 1  # type: Union[int, str]
if isinstance(x, str):
    cast(str, x)
[builtins fixtures/isinstance.py]
[out]
main:5: note: Redundant cast to "str"

[case testCastToSuperclassNotRedundant]
# flags: warn-redundant-casts
from typing import cast, TypeVar, List
T = TypeVar('T')
def add(xs: List[T], ys: List[T]) -> List[T]: pass
class A: pass
class B(A): pass
a = A()
b = B()
# Without the cast, the following line would fail to type check.
c = add([cast(A, b)], [a])
[builtins fixtures/list.py]


-- Unused 'type: ignore' comments
-- ------------------------------

[case testUnusedTypeIgnore]
# flags: warn-unused-ignores
a = 1
a = 'a' # type: ignore
a = 2 # type: ignore # N: unused 'type: ignore' comment
a = 'b' # E: Incompatible types in assignment (expression has type "str", variable has type "int")

[case testUnusedTypeIgnoreImport]
# flags: warn-unused-ignores
# Never warn about `type: ignore` comments on imports.
import banana # type: ignore
import m # type: ignore
from m import * # type: ignore
[file m.py]
pass
[out]


-- No return
-- ---------

[case testNoReturn]
# flags: warn-no-return
def f() -> int:
    pass

def g() -> int:
    if bool():
        return 1
[builtins fixtures/list.py]
[out]
main: note: In function "g":
main:5: note: Missing return statement

[case testNoReturnWhile]
# flags: warn-no-return
def h() -> int:
    while True:
        if bool():
            return 1

def i() -> int:
    while 1:
        if bool():
            return 1
        if bool():
            break

def j() -> int:
    while 1:
        if bool():
            return 1
        if bool():
            continue
[builtins fixtures/list.py]
[out]
main: note: In function "i":
main:7: note: Missing return statement

[case testNoReturnExcept]
# flags: warn-no-return
def f() -> int:
    try:
        return 1
    except:
        pass
def g() -> int:
    try:
        pass
    except:
        return 1
    else:
        return 1
def h() -> int:
    try:
        pass
    except:
        pass
    else:
        pass
    finally:
        return 1
[builtins fixtures/exception.py]
[out]
main: note: In function "f":
main:2: note: Missing return statement
